// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package database

import (
	"context"
	"database/sql"
)

const clearFeedError = `-- name: ClearFeedError :exec
UPDATE feeds
SET last_error = NULL, last_error_time = NULL
WHERE id = ?
`

func (q *Queries) ClearFeedError(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, clearFeedError, id)
	return err
}

const createFeed = `-- name: CreateFeed :one
INSERT INTO feeds (url, title, description, last_updated, visible)
VALUES (?, ?, ?, ?, ?)
RETURNING id, url, title, description, last_updated, last_error, last_error_time, visible, created_at, etag, last_modified, cache_control_max_age
`

type CreateFeedParams struct {
	Url         string       `json:"url"`
	Title       string       `json:"title"`
	Description string       `json:"description"`
	LastUpdated sql.NullTime `json:"last_updated"`
	Visible     bool         `json:"visible"`
}

func (q *Queries) CreateFeed(ctx context.Context, arg CreateFeedParams) (Feed, error) {
	row := q.db.QueryRowContext(ctx, createFeed,
		arg.Url,
		arg.Title,
		arg.Description,
		arg.LastUpdated,
		arg.Visible,
	)
	var i Feed
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Title,
		&i.Description,
		&i.LastUpdated,
		&i.LastError,
		&i.LastErrorTime,
		&i.Visible,
		&i.CreatedAt,
		&i.Etag,
		&i.LastModified,
		&i.CacheControlMaxAge,
	)
	return i, err
}

const createItem = `-- name: CreateItem :one
INSERT INTO items (feed_id, guid, title, description, content, link, published)
VALUES (?, ?, ?, ?, ?, ?, ?)
RETURNING id, feed_id, guid, title, description, content, link, published, created_at
`

type CreateItemParams struct {
	FeedID      int64        `json:"feed_id"`
	Guid        string       `json:"guid"`
	Title       string       `json:"title"`
	Description string       `json:"description"`
	Content     string       `json:"content"`
	Link        string       `json:"link"`
	Published   sql.NullTime `json:"published"`
}

func (q *Queries) CreateItem(ctx context.Context, arg CreateItemParams) (Item, error) {
	row := q.db.QueryRowContext(ctx, createItem,
		arg.FeedID,
		arg.Guid,
		arg.Title,
		arg.Description,
		arg.Content,
		arg.Link,
		arg.Published,
	)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.FeedID,
		&i.Guid,
		&i.Title,
		&i.Description,
		&i.Content,
		&i.Link,
		&i.Published,
		&i.CreatedAt,
	)
	return i, err
}

const createLogMessage = `-- name: CreateLogMessage :exec
INSERT INTO log_messages (level, message, timestamp, attributes)
VALUES (?, ?, ?, ?)
`

type CreateLogMessageParams struct {
	Level      string         `json:"level"`
	Message    string         `json:"message"`
	Timestamp  sql.NullTime   `json:"timestamp"`
	Attributes sql.NullString `json:"attributes"`
}

func (q *Queries) CreateLogMessage(ctx context.Context, arg CreateLogMessageParams) error {
	_, err := q.db.ExecContext(ctx, createLogMessage,
		arg.Level,
		arg.Message,
		arg.Timestamp,
		arg.Attributes,
	)
	return err
}

const deleteAllLogMessages = `-- name: DeleteAllLogMessages :exec
DELETE FROM log_messages
`

func (q *Queries) DeleteAllLogMessages(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllLogMessages)
	return err
}

const deleteFeed = `-- name: DeleteFeed :exec
DELETE FROM feeds WHERE id = ?
`

func (q *Queries) DeleteFeed(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteFeed, id)
	return err
}

const deleteItemsByFeed = `-- name: DeleteItemsByFeed :exec
DELETE FROM items WHERE feed_id = ?
`

func (q *Queries) DeleteItemsByFeed(ctx context.Context, feedID int64) error {
	_, err := q.db.ExecContext(ctx, deleteItemsByFeed, feedID)
	return err
}

const deleteSetting = `-- name: DeleteSetting :exec
DELETE FROM settings WHERE key = ?
`

func (q *Queries) DeleteSetting(ctx context.Context, key string) error {
	_, err := q.db.ExecContext(ctx, deleteSetting, key)
	return err
}

const getAllSettings = `-- name: GetAllSettings :many
SELECT key, value, updated_at FROM settings ORDER BY key
`

func (q *Queries) GetAllSettings(ctx context.Context) ([]Setting, error) {
	rows, err := q.db.QueryContext(ctx, getAllSettings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Setting
	for rows.Next() {
		var i Setting
		if err := rows.Scan(&i.Key, &i.Value, &i.UpdatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFeed = `-- name: GetFeed :one
SELECT id, url, title, description, last_updated, last_error, last_error_time, visible, created_at, etag, last_modified, cache_control_max_age FROM feeds WHERE id = ?
`

func (q *Queries) GetFeed(ctx context.Context, id int64) (Feed, error) {
	row := q.db.QueryRowContext(ctx, getFeed, id)
	var i Feed
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Title,
		&i.Description,
		&i.LastUpdated,
		&i.LastError,
		&i.LastErrorTime,
		&i.Visible,
		&i.CreatedAt,
		&i.Etag,
		&i.LastModified,
		&i.CacheControlMaxAge,
	)
	return i, err
}

const getFeedByURL = `-- name: GetFeedByURL :one
SELECT id, url, title, description, last_updated, last_error, last_error_time, visible, created_at, etag, last_modified, cache_control_max_age FROM feeds WHERE url = ?
`

func (q *Queries) GetFeedByURL(ctx context.Context, url string) (Feed, error) {
	row := q.db.QueryRowContext(ctx, getFeedByURL, url)
	var i Feed
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Title,
		&i.Description,
		&i.LastUpdated,
		&i.LastError,
		&i.LastErrorTime,
		&i.Visible,
		&i.CreatedAt,
		&i.Etag,
		&i.LastModified,
		&i.CacheControlMaxAge,
	)
	return i, err
}

const getFeedStats = `-- name: GetFeedStats :many
SELECT
    f.id,
    f.title,
    f.url,
    f.last_error,
    f.last_error_time,
    COUNT(i.id) as total_items,
    COUNT(CASE WHEN i.id IS NOT NULL AND COALESCE(rs.read, FALSE) = FALSE THEN 1 END) as unread_items
FROM feeds f
LEFT JOIN items i ON f.id = i.feed_id
LEFT JOIN read_status rs ON i.id = rs.item_id
WHERE f.visible = TRUE
GROUP BY f.id, f.title, f.url, f.last_error, f.last_error_time
ORDER BY f.title
`

type GetFeedStatsRow struct {
	ID            int64          `json:"id"`
	Title         string         `json:"title"`
	Url           string         `json:"url"`
	LastError     sql.NullString `json:"last_error"`
	LastErrorTime sql.NullTime   `json:"last_error_time"`
	TotalItems    int64          `json:"total_items"`
	UnreadItems   int64          `json:"unread_items"`
}

func (q *Queries) GetFeedStats(ctx context.Context) ([]GetFeedStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getFeedStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFeedStatsRow
	for rows.Next() {
		var i GetFeedStatsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Url,
			&i.LastError,
			&i.LastErrorTime,
			&i.TotalItems,
			&i.UnreadItems,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItem = `-- name: GetItem :one
SELECT id, feed_id, guid, title, description, content, link, published, created_at FROM items WHERE id = ?
`

func (q *Queries) GetItem(ctx context.Context, id int64) (Item, error) {
	row := q.db.QueryRowContext(ctx, getItem, id)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.FeedID,
		&i.Guid,
		&i.Title,
		&i.Description,
		&i.Content,
		&i.Link,
		&i.Published,
		&i.CreatedAt,
	)
	return i, err
}

const getItemsWithReadStatus = `-- name: GetItemsWithReadStatus :many
SELECT
    i.id, i.feed_id, i.guid, i.title, i.description, i.content, i.link, i.published, i.created_at,
    COALESCE(rs.read, FALSE) as read
FROM items i
LEFT JOIN read_status rs ON i.id = rs.item_id
WHERE i.feed_id = ?
ORDER BY i.published DESC
`

type GetItemsWithReadStatusRow struct {
	ID          int64        `json:"id"`
	FeedID      int64        `json:"feed_id"`
	Guid        string       `json:"guid"`
	Title       string       `json:"title"`
	Description string       `json:"description"`
	Content     string       `json:"content"`
	Link        string       `json:"link"`
	Published   sql.NullTime `json:"published"`
	CreatedAt   sql.NullTime `json:"created_at"`
	Read        bool         `json:"read"`
}

func (q *Queries) GetItemsWithReadStatus(ctx context.Context, feedID int64) ([]GetItemsWithReadStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, getItemsWithReadStatus, feedID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetItemsWithReadStatusRow
	for rows.Next() {
		var i GetItemsWithReadStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.FeedID,
			&i.Guid,
			&i.Title,
			&i.Description,
			&i.Content,
			&i.Link,
			&i.Published,
			&i.CreatedAt,
			&i.Read,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogMessage = `-- name: GetLogMessage :one
SELECT id, level, message, timestamp, attributes
FROM log_messages
WHERE id = ?
`

func (q *Queries) GetLogMessage(ctx context.Context, id int64) (LogMessage, error) {
	row := q.db.QueryRowContext(ctx, getLogMessage, id)
	var i LogMessage
	err := row.Scan(
		&i.ID,
		&i.Level,
		&i.Message,
		&i.Timestamp,
		&i.Attributes,
	)
	return i, err
}

const getLogMessages = `-- name: GetLogMessages :many
SELECT id, level, message, timestamp, attributes
FROM log_messages
ORDER BY timestamp DESC
LIMIT ?
`

func (q *Queries) GetLogMessages(ctx context.Context, limit int64) ([]LogMessage, error) {
	rows, err := q.db.QueryContext(ctx, getLogMessages, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LogMessage
	for rows.Next() {
		var i LogMessage
		if err := rows.Scan(
			&i.ID,
			&i.Level,
			&i.Message,
			&i.Timestamp,
			&i.Attributes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSetting = `-- name: GetSetting :one
SELECT key, value, updated_at FROM settings WHERE key = ?
`

func (q *Queries) GetSetting(ctx context.Context, key string) (Setting, error) {
	row := q.db.QueryRowContext(ctx, getSetting, key)
	var i Setting
	err := row.Scan(&i.Key, &i.Value, &i.UpdatedAt)
	return i, err
}

const hideFeed = `-- name: HideFeed :exec
UPDATE feeds SET visible = FALSE WHERE id = ?
`

func (q *Queries) HideFeed(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, hideFeed, id)
	return err
}

const hideFeedByURL = `-- name: HideFeedByURL :exec
UPDATE feeds SET visible = FALSE WHERE url = ?
`

func (q *Queries) HideFeedByURL(ctx context.Context, url string) error {
	_, err := q.db.ExecContext(ctx, hideFeedByURL, url)
	return err
}

const isItemRead = `-- name: IsItemRead :one
SELECT COALESCE(read, FALSE) as read
FROM read_status
WHERE item_id = ?
`

func (q *Queries) IsItemRead(ctx context.Context, itemID int64) (bool, error) {
	row := q.db.QueryRowContext(ctx, isItemRead, itemID)
	var read bool
	err := row.Scan(&read)
	return read, err
}

const listAllFeeds = `-- name: ListAllFeeds :many
SELECT id, url, title, description, last_updated, last_error, last_error_time, visible, created_at, etag, last_modified, cache_control_max_age FROM feeds ORDER BY title
`

func (q *Queries) ListAllFeeds(ctx context.Context) ([]Feed, error) {
	rows, err := q.db.QueryContext(ctx, listAllFeeds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Feed
	for rows.Next() {
		var i Feed
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.LastUpdated,
			&i.LastError,
			&i.LastErrorTime,
			&i.Visible,
			&i.CreatedAt,
			&i.Etag,
			&i.LastModified,
			&i.CacheControlMaxAge,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFeeds = `-- name: ListFeeds :many
SELECT id, url, title, description, last_updated, last_error, last_error_time, visible, created_at, etag, last_modified, cache_control_max_age FROM feeds WHERE visible = TRUE ORDER BY title
`

func (q *Queries) ListFeeds(ctx context.Context) ([]Feed, error) {
	rows, err := q.db.QueryContext(ctx, listFeeds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Feed
	for rows.Next() {
		var i Feed
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.Description,
			&i.LastUpdated,
			&i.LastError,
			&i.LastErrorTime,
			&i.Visible,
			&i.CreatedAt,
			&i.Etag,
			&i.LastModified,
			&i.CacheControlMaxAge,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listItemsByFeed = `-- name: ListItemsByFeed :many
SELECT id, feed_id, guid, title, description, content, link, published, created_at FROM items
WHERE feed_id = ?
ORDER BY published DESC
`

func (q *Queries) ListItemsByFeed(ctx context.Context, feedID int64) ([]Item, error) {
	rows, err := q.db.QueryContext(ctx, listItemsByFeed, feedID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Item
	for rows.Next() {
		var i Item
		if err := rows.Scan(
			&i.ID,
			&i.FeedID,
			&i.Guid,
			&i.Title,
			&i.Description,
			&i.Content,
			&i.Link,
			&i.Published,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markAllItemsReadInFeed = `-- name: MarkAllItemsReadInFeed :exec
INSERT INTO read_status (item_id, read, read_at)
SELECT i.id, TRUE, CURRENT_TIMESTAMP
FROM items i
WHERE i.feed_id = ?
ON CONFLICT(item_id) DO UPDATE SET
    read = TRUE,
    read_at = CURRENT_TIMESTAMP
`

func (q *Queries) MarkAllItemsReadInFeed(ctx context.Context, feedID int64) error {
	_, err := q.db.ExecContext(ctx, markAllItemsReadInFeed, feedID)
	return err
}

const markItemRead = `-- name: MarkItemRead :exec
INSERT INTO read_status (item_id, read, read_at)
VALUES (?, TRUE, CURRENT_TIMESTAMP)
ON CONFLICT(item_id) DO UPDATE SET
    read = TRUE,
    read_at = CURRENT_TIMESTAMP
`

func (q *Queries) MarkItemRead(ctx context.Context, itemID int64) error {
	_, err := q.db.ExecContext(ctx, markItemRead, itemID)
	return err
}

const markItemUnread = `-- name: MarkItemUnread :exec
INSERT INTO read_status (item_id, read)
VALUES (?, FALSE)
ON CONFLICT(item_id) DO UPDATE SET
    read = FALSE,
    read_at = NULL
`

func (q *Queries) MarkItemUnread(ctx context.Context, itemID int64) error {
	_, err := q.db.ExecContext(ctx, markItemUnread, itemID)
	return err
}

const setSetting = `-- name: SetSetting :exec
INSERT INTO settings (key, value, updated_at)
VALUES (?, ?, CURRENT_TIMESTAMP)
ON CONFLICT(key) DO UPDATE SET
    value = excluded.value,
    updated_at = CURRENT_TIMESTAMP
`

type SetSettingParams struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

func (q *Queries) SetSetting(ctx context.Context, arg SetSettingParams) error {
	_, err := q.db.ExecContext(ctx, setSetting, arg.Key, arg.Value)
	return err
}

const showFeed = `-- name: ShowFeed :exec
UPDATE feeds SET visible = TRUE WHERE id = ?
`

func (q *Queries) ShowFeed(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, showFeed, id)
	return err
}

const showFeedByURL = `-- name: ShowFeedByURL :exec
UPDATE feeds SET visible = TRUE WHERE url = ?
`

func (q *Queries) ShowFeedByURL(ctx context.Context, url string) error {
	_, err := q.db.ExecContext(ctx, showFeedByURL, url)
	return err
}

const updateFeed = `-- name: UpdateFeed :exec
UPDATE feeds
SET title = ?, description = ?, last_updated = ?, etag = ?, last_modified = ?, cache_control_max_age = ?
WHERE id = ?
`

type UpdateFeedParams struct {
	Title              string         `json:"title"`
	Description        string         `json:"description"`
	LastUpdated        sql.NullTime   `json:"last_updated"`
	Etag               sql.NullString `json:"etag"`
	LastModified       sql.NullString `json:"last_modified"`
	CacheControlMaxAge sql.NullInt64  `json:"cache_control_max_age"`
	ID                 int64          `json:"id"`
}

func (q *Queries) UpdateFeed(ctx context.Context, arg UpdateFeedParams) error {
	_, err := q.db.ExecContext(ctx, updateFeed,
		arg.Title,
		arg.Description,
		arg.LastUpdated,
		arg.Etag,
		arg.LastModified,
		arg.CacheControlMaxAge,
		arg.ID,
	)
	return err
}

const updateFeedError = `-- name: UpdateFeedError :exec
UPDATE feeds
SET last_error = ?, last_error_time = ?
WHERE id = ?
`

type UpdateFeedErrorParams struct {
	LastError     sql.NullString `json:"last_error"`
	LastErrorTime sql.NullTime   `json:"last_error_time"`
	ID            int64          `json:"id"`
}

func (q *Queries) UpdateFeedError(ctx context.Context, arg UpdateFeedErrorParams) error {
	_, err := q.db.ExecContext(ctx, updateFeedError, arg.LastError, arg.LastErrorTime, arg.ID)
	return err
}

const upsertItem = `-- name: UpsertItem :one
INSERT INTO items (feed_id, guid, title, description, content, link, published)
VALUES (?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(feed_id, guid) DO UPDATE SET
    title = excluded.title,
    description = excluded.description,
    content = excluded.content,
    link = excluded.link,
    published = excluded.published
RETURNING id, feed_id, guid, title, description, content, link, published, created_at
`

type UpsertItemParams struct {
	FeedID      int64        `json:"feed_id"`
	Guid        string       `json:"guid"`
	Title       string       `json:"title"`
	Description string       `json:"description"`
	Content     string       `json:"content"`
	Link        string       `json:"link"`
	Published   sql.NullTime `json:"published"`
}

func (q *Queries) UpsertItem(ctx context.Context, arg UpsertItemParams) (Item, error) {
	row := q.db.QueryRowContext(ctx, upsertItem,
		arg.FeedID,
		arg.Guid,
		arg.Title,
		arg.Description,
		arg.Content,
		arg.Link,
		arg.Published,
	)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.FeedID,
		&i.Guid,
		&i.Title,
		&i.Description,
		&i.Content,
		&i.Link,
		&i.Published,
		&i.CreatedAt,
	)
	return i, err
}
